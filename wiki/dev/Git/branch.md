---
id: Branch
title: Branch
sidebar_position: 3
data: January 13, 2022
---

Git's branching model is called its "nirvana feature", and it is because of this feature that Git stands out from many version control systems.

## Branch introduction

Because Git does not save changes or differences in files, but a series of snapshots at different times.

So when committing, Git saves a commit object. The commit object will contain a pointer to a snapshot of the staging content, as well as the author's name and email address entered at the time of the commit, and a pointer to its parent object. The commit object generated by the first commit has no parent object, the commit object generated by the common commit operation has one parent object, and the commit object generated by merging multiple branches has multiple parent objects.

**Git branches are essentially just mutable pointers to commit objects. **

### Create branch

```shell
// create branch
git branch <branch-name>
```

This creates a pointer to the current commit object.

### Branch switching

To switch to an existing branch, you need to use the git checkout command.

```shell
// switch to an existing branch
git checkout <branch-name>

// Create a new branch on the current commit object and switch to the new branch.
git checkout -b <branch-name>
```

### View branch

```shell
// View created branches
git branch
```

### Merge branches

```shell
// Merge the branch into the current branch.
git merge <branch-name>
```

### delete branch

```shell
git branch -d <branch-name>
```

## Branch instance

You will go through the following steps:

1. Develop a website.

2. To implement a new user requirement, create a branch.

3. Work on this branch.

At this point, you suddenly receive a call saying that there is a serious problem that needs to be fixed urgently. You will proceed as follows:

1. Switch to your production branch.
2. Create a new branch for this urgent task and fix it there.
3. After the test passes, switch back to the live branch, then merge the patched branch, and finally push the changes to the live branch.
4. Switch back to the branch you originally worked on and continue working.

### New branch

First, let's assume you are working on your project and already have some commits on the master branch.

Now, you create a branch iss53 to implement a new requirement.

```shell
git checkout -b iss53
```

When we made some commits, the iss53 branch was moving forward.

Now you get that call, there is an urgent issue waiting for you to resolve, all you have to do now is switch back to the master branch.

```shell
git checkout master
```

Next, you want to fix this urgent problem. Create a new hotfix branch until the problem is solved.

```shell
git checkout -b hotfix
```

### Merging of branches

Then merge the hotfix branch back into your master branch to deploy live.

```shell
git checkout master
git merge hotfix
```

When you try to merge two branches, if you can go down one branch to reach the other, then Git will simply advance the pointer (move the pointer right) when merging the two, because this is the case The merge operation below has no disagreements to resolve - this is called "fast-forward".

At this point, the hotfix branch is no longer needed and can be deleted.

```shell
git branch -d hotfix
```

Now you switch back to the branch you were working on, continue your work, and have the new commit.

Assuming that you have completed the iss53 requirements at this point, you need to merge the iss53 branch into the master branch.

```shell
git checkout master
git merge iss53
```

This looks a little different than when merging hotfix branches earlier.

In this case, your development history diverged from an earlier point. Because the commit on the master branch is not a direct ancestor of the commit on the iss53 branch, Git has to do some extra work. When this happens, Git will do a simple three-way merge using the snapshots pointed to by the ends of the two branches and the common ancestor of the two branches.

### Branch merge when encountering conflicts

Sometimes the merge operation doesn't go so smoothly, because if the same part of the same file is involved, there will be conflicts when merging. At this point Git did the merge, but did not automatically create a new merge commit. Git will pause and wait for you to resolve the merge conflicts.

Any files that are pending resolution because they contain merge conflicts are identified as unmerged. Git adds standard conflict resolution markers to conflicting files, so that you can open the conflicting files and resolve them manually.

Conflicting files will contain special sections like this:

```shell
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```

This means that the version indicated by HEAD (which is where your master branch is, since you checked out this branch when you ran the merge command) is in the upper half of this section (======= the top half).

The version indicated by the iss53 branch is in the lower half of =======. To resolve conflicts, you must choose to use one of the two parts separated by =======, or you can merge the contents yourself.

For example, you can resolve the conflict by replacing this content with the following:

```shell
<div id="footer">
please contact us at email.support@github.com
</div>
```

The conflict resolution above preserves only the modifications of one of the branches, and the lines <<<<<<< , ======= , and >>>>>>>> are completely deleted. After you've resolved conflicts in all files, use the git add command on each file to mark it as conflict resolved. Once these otherwise conflicting files are staged, Git marks them as conflict resolved.

## remote branch

A remote reference is a reference (pointer) to a remote repository, including branches, tags, etc. Think of them as bookmarks to remind you that the location of the branch in the remote is where you last connected to them.

### Push branch

When you want to share a branch publicly, you need to push it to a remote repository with write permissions. ** Local branches are not automatically synced with remote repositories - you must explicitly push the branch you want to share. **

```shell
// push the local branch to the tracking remote branch
git push <remote> <branch>

// Push the local branch to the remote branch (custom remote branch naming)
git push <remote> <branch>:<origin-branch-name>
```

### Tracking branches

Checking out a local branch from a remote-tracking branch automatically creates what is called a "tracking branch" (the branch it tracks is called an "upstream branch"). A tracking branch is a local branch that has a direct relationship to a remote branch.

```shell
// Create a new local tracking branch from the remote branch
git checkout --track <remote>/<branch>

// Create a new local tracking branch from the remote branch (custom local branch naming)
git checkout -b <branch> <remote>/<branch>

// modify the tracked remote branch
git branch -u <remote>/<branch>

// View all tracking branches that are set
git branch -vv
```

### Pull

You can run git fetch or git pull when fetching data from the server that is not available locally. It is recommended to use the fetch and merge commands explicitly and separately.

```shell
// Only pull the default remote branch data, do not automatically merge.
git fetch <remote>

// Pull the remote branch and try to merge it automatically.
git pull <remote>
```

### delete remote branch

```shell
git push <remote> --delete <branch>
```

## rebase

You can use the rebase command to move all changes committed on one branch to another, as if "replaying" them. In Git, this operation is called a rebase.

```shell
git rebase <base-branch> <topic-branch>
```

Its principle is to first find the nearest common ancestor of these two branches (assuming the current branch experiment, the target base branch master of the rebase operation), and then compare the previous commits of the current branch relative to the ancestor, extract the corresponding changes and save them as temporary files , then point the current branch to the target base, and finally apply the modifications previously saved as a temporary file in order.

```shell
// 1. Switch the experiment branch.
git checkout experiment

// 2. Rebase to master branch.
git rebase master

// 3. Switch the master branch.
git checkout master

// 4. Merge the experiment branch.
git merge experiment
```

### More interesting rebasing examples

When rebasing two branches, the generated "replay" does not have to be applied on the target branch, you can also specify another branch for
application.

You created a server branch from the master branch, added the feature and committed it. The client branch is created based on the submitted server branch, and the function is also added and submitted. You're back in the server branch, continue adding features and committing. Suppose you want to merge the changes in the client into the master branch and publish, but don't want to merge the changes in the server for now, because they still need to be more thoroughly tested.

At this point, you can use the --onto option of the git rebase command to select changes that are in the client branch but not in the server branch, and replay them on the master branch.

```shell
// 1. Take the client branch and find the patch after it diverged from the server branch. These patches are then replayed on the master branch, making the client appear to have modified it directly from master.
git rebase --onto master server client

// 2. Switch master branch
git checkout master

// 3. Merge the client branch
git merge client
```

Next you decide to incorporate the changes in the server branch as well.

```shell
// 1. Rebase to master branch
git rebase master server

// 2. Switch master branch
git checkout master

// 3. Merge the branch
git merge server

// 4. Delete the branch
```

### Risk of rebasing

If commits exist outside of your repository and someone else might be developing based on those commits, then don't perform a rebase.

If you follow this golden rule, you can't go wrong. Otherwise, the people will hate you, and your friends and family will laugh at you and spit at you.

### Rebase vs Merge

At this point, you have learned the use of rebase and merge in practice, and you will definitely want to ask which method is better. Before answering this question, let's take a step back and want to discuss what commit history really means.

There is an argument that the commit history of a repository is a record of what actually happened. It is a historical document, which is valuable in itself and cannot be altered arbitrarily. From this point of view, changing the commit history is blasphemy, you're using a lie to cover up what actually happened. If the proposal resulting from the merger

What if the history is a mess? Since this is the case, these traces should be preserved for future reference. Another view is just the opposite, they see the commit history as something that happens during the course of the project. No one publishes the first draft of a book, and software maintenance manuals require repeated revisions to be easy to use. People who hold this point of view use tools like rebase and filter-branch to write stories, whatever makes it convenient for later readers.

Now, let's go back to the previous question, is it better to merge or rebase? Hope you understand that there is no easy answer to this. Git is a very powerful tool that allows you to do many things with your commit history, but every team and every project has different needs for this. Now that you have learned the usage of the two separately, I believe you can make a wise choice according to the actual situation.

The general principle is to only perform rebasing operations on local changes that have not been pushed or shared with others to clean up the history, and never perform rebasing operations on commits that have been pushed elsewhere. In this way, you can enjoy the convenience brought by both methods.
